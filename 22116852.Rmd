---
title: "Assignment"
author: "Kushal Piya"
date: "2025-02-24"
output:
  word_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Question1
## i,ii 
![Fibonacci Flow Chart](Fibonacci.png)
```{r}
fibSequence<- function(len = 10){
  if(len <=0){
    stop("Length should be greater than 1.")
  }
  fibSeq <- numeric(len)
  fibSeq[1] <- 0
  if (len > 1) {
    fibSeq[2] <- 1
  }
  if (len >2){
    for (i in 3:len) {
      fibSeq[i] <- fibSeq[i - 1] + fibSeq[i - 2]
    }
  }
  
  res <- list(cSeqType = "Fibonacci", 
              nSeqLen = len, 
              iFibSeq = fibSeq)
  return(res)
}

fibonacci1 <- fibSequence(1)
fibonacci35 <- fibSequence(35)

print(fibonacci1)
print(fibonacci35)
```

## Question 1
## iii

```{r}
mySequence <- function(len = 10) {
  # len = requested sequence length
  sequence_result <- c()
  # Starting from 1 until we get 'len' number of sequence
  number <- 1
  while (length(sequence_result)<len) {
    # Divisible by 2 and 3 or not
    if (number%%2 != 0 && number%%3 != 0) {
      sequence_result <- c(sequence_result,number)
    }
    number <- number + 1 #Checking next number
  }
  # Package the results 
  
  res <- list(cSeqType = "Not divisible by 2 or 3", 
              nSeqLen = len, 
              iMySeq = sequence_result) 
  return(res) 
}

sequence1 <- mySequence(1)
sequence56 <- mySequence(56)

print(sequence1)
print(sequence56)
```

## Question 2
## i
```{r}
species_boxplots <- function(){
  par(mfrow = c(2,2))
  # Box plot for Sepal Length by Species
  boxplot(Sepal.Length~Species,data = iris,
          main ="Sepal Length", xlab = "Species",ylab = "Sepal Length",
          col = c("red","lightgreen","lightblue"))
  # Box plot for Sepal Width by Species
  boxplot(Sepal.Width~Species,data = iris,
          main ="Sepal Width", xlab = "Species",ylab = "Sepal Width",
          col = c("red","lightgreen","lightblue"))
  # Box plot for Petal Length by Species
  boxplot(Petal.Length~Species,data = iris,
          main ="Petal Length", xlab = "Species",ylab = "Petal Length",
          col = c("red","lightgreen","lightblue"))
  # Box plot for Petal Width by Species
  boxplot(Petal.Width~Species,data = iris,
          main ="Petal Width", xlab = "Species",ylab = "Petal Width",
          col = c("red","lightgreen","lightblue"))
}
species_boxplots()
```

## Question 2
## ii
```{r}
outlierThresholds <- function(x, k = 1.5) { 
  # x = vector to be processed
  # note x belongs to a single category of data
  # k = k value to be used by Tukey's approach
  q1 <- quantile(x,probs = 0.25)
  
  q3 <- quantile(x,probs = 0.75)
  
  # Calculating the interquartile range
  iqr <- q3-q1
  
  # Calculating the lower and upper thresholds using Tukey's fences
  lowerThreshold <- q1 - k*iqr
  upperThreshold <- q3 + k*iqr
  
  # Returning the thresholds as vector
  result <- c(Upper = upperThreshold,Lower = lowerThreshold)
  return(result)
}
outlierThresholds(iris$Sepal.Length)
```
## Question 2
## iii
```{r}
outlierIds_helper <- function(x, k = 1.5) {
  # x = vector to be processed
  # note x belongs to a single category of data
  # k = k value to be used by Tukey's approach
  q1 <- quantile(x,probs = 0.25)
  
  q3 <- quantile(x,probs = 0.75)
  
  # Calculating the interquartile range
  iqr <- q3-q1
  
  # Calculating the lower and upper thresholds using Tukey's fences
  lowerThreshold <- q1 - k*iqr
  upperThreshold <- q3 + k*iqr
  
  # Finding the indices of outliers
  outlier_indices <- which(x < lowerThreshold | x > upperThreshold)
  
  if (length(outlier_indices)==0) {
    return(NULL)
  }
  else{
    # Returning indices of outliers
    return(outlier_indices)
  }
}

outlierIds_helper(iris$Sepal.Length)
```
## Question 3
## i
```{r}
outliers <-function(x, mask, k = 1.5) {
  # x = is the data set to be processed, for our purposes the entire iris data set 
  # mask = is a vector containing the species of the row in x being processed 
  # k = k value to be used by Tukey approach
  
  res <- list()
  speciesLevels <- unique(mask)
  for(columnName in colnames(x)){
    columnList <- list()
    
    for (speciesName in speciesLevels) {
      sub_data <- x[mask == speciesName , columnName]
      
      outliers_in_sub_data <- outlierIds_helper(sub_data,k)
      
      if (!is.null(outliers_in_sub_data)) {
        allOutliers <- which(mask == speciesName)[outliers_in_sub_data]
        columnList[[speciesName]] <- allOutliers
      } else {
        columnList[[speciesName]] <- numeric(0)
      }
    }
    res[[columnName]] <- columnList
  }
  return(res)
  }
res <-outliers(iris[,-5], iris$Species) 
res
```
## Question 3
## ii
```{r}

outliersExt <-function(x, mask, k = 1.5, 
                       colSelect = c("Sepal.Length", "Sepal.Width", 
                                     "Petal.Length", "Petal.Width")) { 
  # x = is the data set to be processed; entire iris data set 
  # mask = is a vector containing the species of the row in x being processed 
  # k = k value to be used by Tukey approach 
  # colSelect = one or more numeric columns to used
  # y = new subset of x res <-outliers(y, mask, k) 
  y <- x[,colSelect, drop = FALSE] # drop = FALSE returns a data frame of one column instead of vector
  
  res<- outliers(y,mask,k)
  
  rows_with_outliers <- unique(unlist(res))
  

  
  outlier_count <- length(rows_with_outliers)
  result <- list(
    outliers = res,
    rowsWithOutliers = rows_with_outliers,
    outlierCount = outlier_count
  )
  return(result)
  }

outliersExt(iris[, -5], iris$Species, colSelect = 'Sepal.Length')
```

## Question 3
## iii
In this experiment, I found the minimum value of k that results in fewer than 10 outliers when OutliersExt() function is applied to entire iris dataset. The experiment involved adjusting k gradually in place of first decimal starting with 1.5. 
When k = 1.5, the number of outliers was 13.
When k = 1.6, the number of outliers was 11.
When k = 1.7, the number of outliers was 8.
As we have found that, with k = 1.7 the number of outliers was below 10 which satisfies our condition. 

## Question 4
## i
```{r}
outlierPlot <- function(x, outlierIDs = NULL, 
                        axes = c("Sepal.Length", "Sepal.Width")) {
  # x = is the data set to be processed 
  # outliersIDs = outlier data generated by earlier developed code 
  # axes = axes to be shown
  species_colors <- c("setosa" = "red", "versicolor" = "green", "virginica" = "blue")
  all_outliers <- unique(unlist(outlierIDs))
  non_outliers <- setdiff(1:nrow(x), all_outliers)
  plot(x[non_outliers, axes[1]], x[non_outliers, axes[2]], 
       col = species_colors[x$Species[non_outliers]], pch = 16, 
       main = "Reliable versus Outliers", 
       xlab = axes[1], ylab = axes[2])
  if (!is.null(outlierIDs)) {
    for (species in names(species_colors)) {  
      outlier_rows <- unique(unlist(lapply(outlierIDs, `[[`, species)))
      if (length(outlier_rows) > 0) {
        points(x[outlier_rows, axes[1]], x[outlier_rows, axes[2]], 
               col = species_colors[species], 
               pch = 4, cex = 2, lwd = 2)
      }
    }
  }
  legend("topright", inset = c(0, 0), 
         legend = c("setosa", "versicolor", "virginica"), 
         col = c("red", "green", "blue", "black"), pch = c(16, 16, 16, 4), 
         bty = "o", text.col = "black", cex = 0.9)
  text(x = 7.2, y = 1.2, labels = "X indicates an outlier", cex = 1, adj = 0)
}

axes <- c("Sepal.Length", "Sepal.Width")
res <- outliersExt(iris[, -5], iris$Species, k = 1.7, colSelect = axes)
outlierPlot(iris, outlierIDs = res$outliers, axes = axes)
```